---
title: "Day 2: Python Data Types & Variables"
editor: visual
---

## Introduction

In this session, we focus on **how Python stores and works with data**.\
Understanding data types and variables is essential because **all data analysis tasks depend on correctly handling data values**.

::: callout-tip
## Learning Objectives

By the end of this lesson, learners will be able to:

-   Identify common Python data types
-   Assign values to variables
-   Perform basic operations on different data types
:::

------------------------------------------------------------------------

## Variables and Assignment in Python

### What is a Variable?

A **variable** is a name that refers to a value stored in memory.

```{python}
x = 10
y = 5
x + y
```

-   x is the variable name
-   = is the assignment operator
-   10 is the value stored in the variable

Variables allow us to store, reuse, and manipulate data. Variable names should be descriptive and meaningful

### Rules for Naming Variables

-   Must start with a letter or underscore (\_)
-   Cannot start with a number
-   Cannot contain spaces
-   Should be descriptive and meaningful

**Valid variable names**

```{python}
age = 25
total_sales = 5000
```

**Invalid variable names**

```{python}
2age = 25      # starts with a number
total sales = 5000   # contains space
```

## Checking Data Types

Python automatically determines the type of data stored in a variable.

### Common data types:

-   **int** â€“ whole numbers
-   **float** â€“ decimal numbers
-   **str** â€“ text
-   **bool** â€“ True or False values
-   **List (list)** â€“ ordered, changeable

**1. Numeric data types**

```{python}
# - **Integer (int)** - Whole numbers (no decimals):
age = 25
participants = 120

# Check type
type(age)
```

**2. String assignment (text data)**

```{python}

course = "Statistics and Data Analysis"
message = "Welcome to Python!"

# Check Type
type(course)

```

**3. Boolean assignment (True / False)**

```{python}
is_registered = True
has_paid = False
passed_exam = True

# Check Type
type(is_registered)
```

## Numeric Data Types

Python supports several numeric types, but the most commonly used are integers and floats.

### Integers (int)

Integers are whole numbers without decimal points.

```{python}
a = 10
b = -3
```

**Examples of integers:**

Examples of integers:

-   Population counts
-   Number of observations
-   Age in completed years

### Floating-Point Numbers (float)

Floats are numbers with decimal points.

```{python}
height = 1.75
temperature = 36.6
```

**Examples of floats:**

-   Measurements
-   Averages
-   Percentages

## String Data Type (str)

A string is a sequence of characters enclosed in:

-   Single quotes ' '
-   Double quotes " "
-   Triple quotes ''' ''' or """ """ (multi-line strings)

**Key Points**

-   Strings are immutable (cannot be changed)
-   Supports indexing and slicing
-   Used to store text

**Examples**

```{python}
name = "Python"
language = 'Programming'

print(name)
print(type(name))

```

## List Data Type (list)

**Definition**: A list in Python is an ordered, mutable collection of elements. Lists can store items of different data types and allow duplicate values.

A list is one of Pythonâ€™s most versatile data structures. It supports indexing, slicing, modification, iteration, nesting, and dynamic growthâ€”making it essential for data storage and manipulation in Python programs.

**Characteristics of Lists**

| Feature           | Description                            |
|-------------------|----------------------------------------|
| Ordered           | Items maintain insertion order         |
| Mutable           | Elements can be changed after creation |
| Indexed           | Each element has a position index      |
| Allows duplicates | Same value can appear multiple times   |
| Heterogeneous     | Can store different data types         |

**Creating Lists**

**a) Empty list**

```{python}
a = []
```

**b) Using List literal**

```{python}
numbers = [1,2,3,4]
```

**c) Using constructor**

```{python}
letters = list("python")
letters
```

**Indexing**

Lists use zero-based indexing.

```{python}
nums = [10, 20, 30]
print(nums[0])   # 10
print(nums[-1])  # 30 (last element)
```

**Slicing**

Extract portions of a list.

```{python}
nums = [0,1,2,3,4,5]
nums[1:4]     # [1,2,3]
nums[:3]      # [0,1,2]
nums[::2]     # [0,2,4]
```

**Syntax**: list\[start : stop : step\]

| Parameter | Meaning                   |
|-----------|---------------------------|
| start     | Index to begin (included) |
| stop      | Index to end (excluded)   |
| step      | Interval between elements |

**Modifying a List**

Because lists are mutable, you can change elements.

```{python}
nums = [1,2,3]
nums[1] = 100
print(nums)  # [1,100,3]
```

**Common List Methods**

| Method        | Description              | Example         |
|---------------|--------------------------|-----------------|
| `append(x)`   | Adds item to end         | `a.append(5)`   |
| `insert(i,x)` | Inserts at index         | `a.insert(1,9)` |
| `remove(x)`   | Removes first occurrence | `a.remove(3)`   |
| `pop(i)`      | Removes by index         | `a.pop(0)`      |
| `clear()`     | Removes all items        | `a.clear()`     |
| `sort()`      | Sorts list               | `a.sort()`      |
| `reverse()`   | Reverses order           | `a.reverse()`   |

**List Operations**

```{python}
## Concatenation
[1,2] + [3,4]   # [1,2,3,4]

## Repetition
[0] * 4   # [0,0,0,0]

## Membership
3 in [1,2,3]   # True

## Looping Through Lists
for item in [10,20,30]:
    print(item)
### With index:
for i, value in enumerate([10,20,30]):
    print(i, value)
```

**Nested Lists**

Lists can contain other lists.

```{python}
matrix = [[1,2],[3,4],[5,6]]
print(matrix[1][0])  # 3
```

**List Comprehension**

A concise way to create lists.

```{python}
squares = [x**2 for x in range(5)]

## With condition:
evens = [x for x in range(10) if x % 2 == 0]

```

**Copying Lists**

Important: Assigning does NOT copy.

```{python}
a = [1,2,3]
b = a        # same reference
```

Proper copy methods:

```{python}
b = a.copy()
b = list(a)
b = a[:]
```

::: callout-tip
## When to Use Lists

Use lists when you need:

-   Ordered data
-   Modifiable collections
-   Iteration
-   Dynamic storage
-   Storing sequences of results
:::

**Common Errors**

| Error        | Cause                                   |
|--------------|-----------------------------------------|
| `IndexError` | Accessing out-of-range index            |
| `TypeError`  | Invalid operation (e.g., string + list) |
| `ValueError` | Removing value not present              |

## Tuple Data Type (tuple)

**Definition**: A tuple in Python is an ordered, immutable collection of elements. Once created, its elements cannot be changed, added, or removed.

```{python}
my_tuple = (1, 2, 3, "hello", True)
```

**Characteristics of Tuples**

| Feature           | Description                          |
|-------------------|--------------------------------------|
| Ordered           | Maintains insertion order            |
| Immutable         | Cannot be modified after creation    |
| Indexed           | Supports indexing                    |
| Allows duplicates | Same value can appear multiple times |
| Heterogeneous     | Can store mixed data types           |

**Creating Tuples**

```{python}
# a) Empty tuple
t = ()
# b) With elements

nums = (10, 20, 30)

#c) Without parentheses (packing)
t = 1, 2, 3

# d) Single-element tuple (important syntax)
single = (5,)   # comma is required

```

**Other Examples**

```{python}
colors = ("red", "green", "blue")
print(colors)
print(type(colors))


single = (10,)
print(type(single))  # tuple
```

**Indexing**: Tuples support zero-based indexing.

```{python}

t = (10, 20, 30)
print(t[0])   # 10
print(t[-1])  # 30
```

**Slicing**: Works the same as lists.

```{python}
t = (0,1,2,3,4)
t[1:4]     # (1,2,3)
t[:3]      # (0,1,2)
t[::2]     # (0,2,4)
```

**Immutability**:

You cannot modify tuple elements.

```{python}
t = (1,2,3)
t[1] = 100   # âŒ Error

## Error:
TypeError: 'tuple' object does not support item assignment
```

However, if a tuple contains mutable objects (like lists), those objects can be modified.

```{python}
t = ([1,2], [3,4])
t[0][0] = 99
```

**Tuple Methods**: Tuples have only two built-in methods:

| Method     | Description                  |
|------------|------------------------------|
| `count(x)` | Counts occurrences of value  |
| `index(x)` | Returns first index of value |

```{python}
t = (1,2,2,3)
t.count(2)   # 2
t.index(3)   # 3
```

**Tuple Operations**

```{python}
## Concatenation
(1,2) + (3,4)   # (1,2,3,4)

## Repetition
(0,) * 3   # (0,0,0)

## Membership
3 in (1,2,3)   # True
```

**Packing and Unpacking**

```{python}
## Packing
person = ("Martin", 25, "Statistician")

## Unpacking
name, age, job = person

## Using star unpacking
a, *b = (1,2,3,4)
# a = 1, b = [2,3,4]

```

**Nested Tuples**

```{python}
nested = ((1,2), (3,4))
nested
print(nested[1][0])   # 3

# nested[1][0] means:

#> â€œGo to index 1 of nested, then from that result go to index 0.â€
```

::: callout-tip
## When to Use Tuples

Use tuples when:

-   Data should not change
-   You need data integrity
-   Storing constants
-   Returning multiple values from functions
-   Using data as dictionary keys
:::

::: callout-tip
## Advantages of Tuples

-   Faster than lists
-   Memory efficient
-   Safe from accidental modification
-   Hashable (can be dictionary keys if elements are immutable)
:::

**Common Errors**

| Error        | Cause                               |
|--------------|-------------------------------------|
| `TypeError`  | Trying to modify tuple              |
| `ValueError` | Unpacking wrong number of variables |

```{python}
a, b = (1,2,3)   # âŒ ValueError
```

**Practical Examples**: Returning multiple values

```{python}
def stats(x, y):
    return x+y, x*y

s, p = stats(2,3)
```

**Dictionary key**

```{phton}
location = {(1,2): "Point A"}
```

::: callout-tip
## List vs Tuple

| Feature     | Tuple      | List            |
|-------------|------------|-----------------|
| Mutability  | Immutable  | Mutable         |
| Syntax      | `( )`      | `[ ]`           |
| Methods     | Few        | Many            |
| Performance | Faster     | Slightly slower |
| Use case    | Fixed data | Changing data   |
:::

## Set Data Type (set)

**Definition**: A set in Python is an unordered, mutable collection of unique elements. Sets are mainly used for membership testing, removing duplicates, and mathematical set operations.

```{python}
my_set = {1, 2, 3, 4}
```

**Characteristics of Sets**

| Feature         | Description                                |
|-----------------|--------------------------------------------|
| Unordered       | No fixed position of elements              |
| Mutable         | Elements can be added or removed           |
| Unique elements | Duplicate values are automatically removed |
| Unindexed       | Cannot access elements by position         |
| Iterable        | Can loop through elements                  |

**Creating Sets**

```{python}

# a) Using curly braces
s = {1, 2, 3}

# b) Using constructor
s = set([1, 2, 3])

# c) Empty set (important)

s = set()   # correct

```

> {} creates a dictionary, not a set.

**Duplicate Removal**

```{python}
nums = {1,1,2,2,3}
print(nums)


nums = [1,2,2,3,3,4]
unique = list(set(nums))
```

**Adding Elements**

```{python}
s = {1,2}
s.add(3)
```

**Add multiple elements:**

```{python}
s.update([4,5,6])
```

**Removing Elements**

| Method       | Description                          |
|--------------|--------------------------------------|
| `remove(x)`  | Removes element; error if not found  |
| `discard(x)` | Removes element; no error if missing |
| `pop()`      | Removes random element               |
| `clear()`    | Removes all elements                 |

**Example:**

```{python}

## Remove(x)
s = {1,2,3}
s.remove(2)

## Discard(x)
p = {3,4,6,7}
p.discard(4)

## pop()
w = {3, 4, 6, 7}
elem = w.pop()  # removes any element (randomly)
print(elem)  # the element removed
print(w)     # the set without that element

## clear()
p = {3, 4, 6, 7}
p.clear()
print(p)  # Output: set(). So use clear() if you want to empty the whole set, not just remove a single element.
```

**Set Operations(Mathematical)**

```{python}
A = {1,2,3}
B = {3,4,5}
```

| Operation            | Symbol  | Result        |
|----------------------|---------|---------------|
| Union                | `A | B` | `{1,2,3,4,5}` |
| Intersection         | `A & B` | `{3}`         |
| Difference           | `A - B` | `{1,2}`       |
| Symmetric Difference | `A ^ B` | `{1,2,4,5}`   |


**Membership Testing**: Sets are very fast for checking membership.

```{python}
3 in {1,2,3}   # True
```

**Iterating Through Sets**

```{python}
for item in {1,2,3}:
    print(item)
```

**Frozen Set (frozenset)**: A frozenset is an immutable version of a set.

```{python}
fs = frozenset([1,2,3])
```

> Order is not guaranteed.

**Properties:**

- Cannot add or remove elements
- Can be used as dictionary keys


::: callout-tip
## When to Use Sets

Use sets when you need:

- Unique values only
- Fast membership checking
- Removing duplicates
- Mathematical operations
- Comparing collections

**Common Errors**

| Error                        | Cause                                    |
| ---------------------------- | ---------------------------------------- |
| `TypeError: unhashable type` | Trying to add list/dict to set           |
| `KeyError`                   | Removing missing element with `remove()` |

```{python}
{1,2}.add([3,4])  # âŒ lists cannot be elements
```
:::

::: callout-tip
##Set vs List vs Tuple

| Feature            | Set     | List   | Tuple  |
| ------------------ | ------- | ------ | ------ |
| Ordered            | No      | Yes    | Yes    |
| Mutable            | Yes     | Yes    | No     |
| Duplicates         | No      | Yes    | Yes    |
| Indexed            | No      | Yes    | Yes    |
| Speed (membership) | Fastest | Slower | Slower |
:::



## Dictionary Data Type (dict)

**Definition**: A dictionary in Python is an unordered, mutable collection of keyâ€“value pairs. Each key must be unique and immutable, while values can be of any data type.

**Characteristics of Dictionaries**

| Feature                  | Description              |
| ------------------------ | ------------------------ |
| Keyâ€“value structure      | Data stored as pairs     |
| Mutable                  | Can modify values        |
| Keys unique              | Duplicate keys overwrite |
| Fast lookup              | Optimized for retrieval  |
| Unordered (conceptually) | No positional indexing   |


**Example**

```{python}
student = {
    "name": "Martin",
    "age": 25,
    "profession": "Statistician"
}

print(student)
print(type(student))
```

**Creating Dictionaries**

```{python}
# a) Using curly braces
d = {"a": 1, "b": 2}

# b) Using constructor
d = dict(a=1, b=2)

# c) Empty dictionary
d = {}
```


**Accessing Values**

Dictionaries use keys instead of indexes.

```{python}
person = {"name":"Martin", "age":25}
person["name"]     # Martin

# Safe access
person.get("age")

```

Difference:

- dict[key] â†’ error if key missing
- dict.get(key) â†’ returns None (or default)

**Modifying Dictionary**

```{python}
# Adding and Updating Items

student["age"] = 21
student["grade"] = "A"
print(student)


d = {"a":1}
d["b"] = 2      # add
d["a"] = 100    # update
```

**Removing Items**


## None Data Type (NoneType)

None represents the absence of a value.

**Key Points**

-   Used when a variable has no value
-   Often used as a default return value

**Examples**

```{python}
result = None
print(result)
print(type(result))


def test():
    pass

print(test())  # None

```

**Dictionary Methods**

| Method     | Description             |
| ---------- | ----------------------- |
| `keys()`   | Returns all keys        |
| `values()` | Returns all values      |
| `items()`  | Returns keyâ€“value pairs |
| `update()` | Merges dictionaries     |
| `copy()`   | Returns copy            |

**Example**

```{python}
d = {"a":1, "b":2}
d.items()

d.keys()
d.copy()
```


```{python}
## Updating with Another Dictionary

student = {"name": "John", "age": 20}
new_data = {"age": 21, "grade": "A"}

student.update(new_data)

print(student)
```

```{python}
## Updating with Key-Value Pairs Directly

student = {"name": "John", "age": 20}

student.update(age=22, city="New York")

print(student)
```

```{python}
## Updating with List of Tuples

student = {"name": "John", "age": 20}

student.update([("age", 23), ("country", "USA")])

print(student)

```

**Iterating Through Dictionaries**

```{python}
# Loop through keys
d = {"a":1, "b":2}
d.items()

for key in d:
    print(key)
    
#Loop through values 
for value in d.values():
    print(value)
    
    
#Loop through both

  for k, v in d.items():
    print(k, v)
```


**Nested Dictionaries**

Dictionaries can contain other dictionaries.

```{python}
students = {
    "s1": {"name":"John", "age":20},
    "s2": {"name":"Jane", "age":21}
}

students["s1"]["name"]   # John
```

**Dictionary Comprehension**

```{python}
squares = {x: x**2 for x in range(5)}
squares
# with condition
evens = {x: x for x in range(10) if x % 2 == 0}
evens
```
::: callout-tip
## When to Use Dictionaries

Use dictionaries when you need:

- Fast lookup by identifier
- Structured data storage
- Mapping relationships
- Named attributes
- Configuration storage
:::


**Common Errors**

| Error        | Cause                 |
| ------------ | --------------------- |
| `KeyError`   | Accessing missing key |
| `TypeError`  | Using mutable key     |
| `ValueError` | Wrong unpacking       |


**Dictionary vs List vs Set**

| Feature           | Dictionary             | List    | Set          |
| ----------------- | ---------------------- | ------- | ------------ |
| Access            | Key                    | Index   | No direct    |
| Order             | Conceptually unordered | Ordered | Unordered    |
| Mutable           | Yes                    | Yes     | Yes          |
| Unique constraint | Keys only              | None    | All elements |


```{python}
d = {"a":1}
d["b"]   # KeyError
```
::: callout-tip
## Practical Examples

**Counting frequencies**

```{python}
text = "banana"
freq = {}

for char in text:
    freq[char] = freq.get(char, 0) + 1
    
# What freq.get(char, 0) does:
# Looks for char in the dictionary.
# If it exists â†’ returns its current value.
# If it does NOT exist â†’ returns 0 (default value).
# Then we add 1 to it.
    
# instead of get we can use:
# if char in freq:
#     freq[char] += 1
# else:
#     freq[char] = 1

```

**Storing records**

```{python}
student = {
    "name": "Martin",
    "score": 95,
    "passed": True
}
```
:::


## Bytes Data Type (bytes)

**Definition**: The bytes data type in Python represents a sequence of raw binary data. It is an immutable sequence of integers where each value must be in the range 0â€“255.

**Examples**

```{python}
data = b"Hello"
print(data)
print(type(data))


numbers = bytes([65, 66, 67])
print(numbers)  # b'ABC'
```

**Characteristics of Bytes**

| Feature     | Description                       |
| ----------- | --------------------------------- |
| Immutable   | Cannot be modified after creation |
| Ordered     | Maintains sequence order          |
| Byte values | Each element is integer (0â€“255)   |
| Binary data | Used for raw data storage         |
| Efficient   | Ideal for file I/O and networking |

**Creating Bytes Objects**

```{python}
# a) Using byte literal
b = b"ABC"

# b) Using constructor
b = bytes([65, 66, 67])

# c) Empty bytes
b = bytes()

```

**Accessing Elements**

```{python}
# Each element is returned as an integer.
b = b"ABC"
b[0]    # 65

#Slice returns bytes:
b[0:2]   # b'AB'
```

**Immutability**

You cannot change a bytes object.

```{python}
b = b"ABC"
b[0] = 70   # âŒ Error

```

**Converting Between Types**


```{python}
# - String â†’ Bytes
text = "hello"
b = text.encode("utf-8")
b
#- Bytes â†’ String
b.decode("utf-8")

# - List â†’ Bytes
bytes([97,98,99])   # b'abc'
```

**Iterating Over Bytes**

```{python}
for byte in b"ABC":
    print(byte)
```

**Bytes Methods (Common)**

| Method         | Description             |
| -------------- | ----------------------- |
| `decode()`     | Converts bytes â†’ string |
| `count()`      | Counts occurrences      |
| `find()`       | Returns index           |
| `startswith()` | Checks prefix           |
| `endswith()`   | Checks suffix           |



::: callout-tip
## When to Use Bytes

Use bytes when working with:

- Files (images, PDFs, audio)
- Network transmission
- Encryption / hashing
- Binary protocols
- Low-level data processing

**Bytes vs Bytearray**

| Feature     | bytes             | bytearray              |
| ----------- | ----------------- | ---------------------- |
| Mutable     | No                | Yes                    |
| Performance | Faster            | Slightly slower        |
| Use case    | Fixed binary data | Modifiable binary data |


**Common Errors**

| Error                | Cause                 |
| -------------------- | --------------------- |
| `TypeError`          | Mixing str and bytes  |
| `UnicodeDecodeError` | Wrong decoding format |
| `ValueError`         | Byte outside 0â€“255    |

:::

**Practical Examples**

```{python}
# Reading binary file
with open("image.png", "rb") as f:
    data = f.read()

# Network data
packet = b"\x48\x49"
```

> **Summary**

> The bytes data type represents immutable sequences of raw binary data. It is essential for handling files, networking, encryption, and any task requiring low-level byte manipulation.

::: {.callout-caution collapse="true"}
## ASCII and UTF-8

**ASCII (American Standard Code for Information Interchange)**

**ASCII** is a character encoding standard used for representing text and control characters in computers and other devices that use text. ASCII assigns a unique number (an integer between 0 and 127) to each character, such as letters, digits, punctuation, and special control characters.

**Key Points About ASCII:**

- **Character Representation**: ASCII provides a way to represent characters (like 'A', 'B', '1', '$', etc.) as numeric codes (0 to 127). For example:
  - `65` represents the letter `'A'`
  - `97` represents the letter `'a'`
  - `48` represents the digit `'0'`

- **7-bit Encoding**: The original ASCII standard uses 7 bits for each character, meaning it can represent 128 different characters (from 0 to 127). The 7th bit was not used initially, so it was effectively a 7-bit code, but extended versions of ASCII can use the 8th bit for additional characters (leading to extended ASCII, which can represent 256 characters).

- **Control Characters**: ASCII includes control characters (with codes from 0 to 31) that control text formatting, like newline, tab, and carriage return. These aren't visible characters but perform specific functions in text processing.

**Common ASCII Characters:**

- **Letters**: 'A' to 'Z' (uppercase) are represented by ASCII values 65â€“90, and 'a' to 'z' (lowercase) by values 97â€“122.
- **Digits**: '0' to '9' are represented by ASCII values 48â€“57.
- **Punctuation**: Characters like `!`, `"`, `#`, etc., are also part of ASCII.
- **Control Characters**: These include characters like `LF` (line feed, 10), `CR` (carriage return, 13), and `ESC` (escape, 27).

**Example of ASCII Table Mapping:**

| ASCII Value | Character |
|-------------|-----------|
| 65          | A         |
| 66          | B         |
| 97          | a         |
| 98          | b         |
| 48          | 0         |
| 32          | (space)   |
| 10          | (newline) |

**Why ASCII Is Important:**

- **Interoperability**: ASCII provides a universal standard for representing text, which allows systems, programs, and devices to exchange text in a consistent and predictable manner.
- **Simplicity**: The original ASCII set was simple and efficient, designed for early computer systems.

In modern computing, ASCII is often extended to 8-bit encodings (like **UTF-8**) to support a wider range of characters, but it remains foundational in character encoding and text processing.

---

**UTF-8 (Unicode Transformation Format - 8-bit)**

**UTF-8** is a variable-width character encoding used to represent text in computers, allowing for the encoding of a vast range of characters from the Unicode standard.

**Key Points About UTF-8:**

- **Unicode Standard**:
  - Unicode is a universal character encoding standard that aims to include every character from every writing system in the world. It provides a unique code point for every character, symbol, or glyph, regardless of platform, program, or language.
  - UTF-8 is one of the most commonly used ways to encode Unicode characters.

- **8-bit Encoding**:
  - UTF-8 uses 8-bit blocks (1 byte) for encoding characters, but it is a variable-length encoding system. This means that some characters take 1 byte, while others can take 2, 3, or even 4 bytes to encode, depending on the character.
  - It was designed to be backward-compatible with ASCII. ASCII characters (which are in the range 0 to 127) are encoded using just 1 byte in UTF-8, making UTF-8 compatible with systems that expect ASCII.

- **Variable-Length Encoding**:
  - In UTF-8, the number of bytes used for a character depends on the character's code point in Unicode:
    - 1 byte (7 bits) for characters in the ASCII range (0â€“127).
    - 2 bytes (11 bits) for characters from the extended ASCII range.
    - 3 bytes for most common characters (like accented characters and many scripts).
    - 4 bytes for less common characters (e.g., some emoji, ancient scripts).

- **Efficient and Flexible**:
  - UTF-8 is efficient for text in English (or languages that use characters in the ASCII range) because it only requires 1 byte for those characters.
  - It is also capable of encoding all the characters in the Unicode standard, including non-Latin scripts, emojis, symbols, and even ancient languages.

**Why UTF-8 is Popular:**

- **Compatibility with ASCII**: Since UTF-8 is compatible with ASCII for characters in the 0â€“127 range, it's easy to integrate into systems that were originally built to handle only ASCII.
- **Compact**: Itâ€™s relatively compact for languages that mainly use ASCII characters (like English), while still being able to handle any character in the world.
- **Widely Used**: UTF-8 is the default encoding in many programming languages, web technologies (like HTML and JSON), and databases.

**Examples of UTF-8 Encoding:**

- The character **'A'** has a Unicode code point of **U+0041**. In UTF-8, it is represented by a single byte:
  - `41` (hexadecimal) = `'A'`

- The character **'â‚¬'** (Euro symbol) has a Unicode code point of **U+20AC**. In UTF-8, it is represented by three bytes:
  - `E2 82 AC` (hexadecimal) = `'â‚¬'`

- The character **'ðˆ'** (an ancient Gothic letter) has a Unicode code point of **U+10348**. In UTF-8, it is represented by four bytes:
  - `F0 90 8D 88` (hexadecimal) = `'ðˆ'`

**Summary of UTF-8:**

- **Variable-length encoding**: UTF-8 can use 1 to 4 bytes per character.
- **Compatibility with ASCII**: For characters in the ASCII range (0â€“127), UTF-8 is identical to ASCII.
- **Universal support**: UTF-8 can encode every character in the Unicode standard.
- **Efficient and flexible**: It efficiently handles characters of different scripts and symbols while being compact for English text.

---

**Differences Between ASCII and UTF-8:**

| Feature               | ASCII                              | UTF-8                                      |
|-----------------------|------------------------------------|--------------------------------------------|
| **Character Range**    | Limited to 128 characters (0â€“127)  | Supports over 1.1 million characters       |
| **Encoding**           | 7-bit encoding                     | Variable-length (1 to 4 bytes per character)|
| **Compatibility**      | Primarily used for English text    | Compatible with ASCII and supports many languages |
| **Character Support**  | Only English letters, digits, punctuation, and control characters | Supports a wide variety of characters from all languages, emojis, and symbols |
| **Efficiency**         | Efficient for English-only text    | Efficient for ASCII text but flexible enough to handle all characters worldwide |
| **Legacy**             | Older standard, widely used in early computing | The most widely used encoding today, particularly for web and applications |

---

**Similarities Between ASCII and UTF-8:**

- **Basic Compatibility**: UTF-8 is fully compatible with ASCII for characters in the range 0â€“127 (the standard ASCII range).
- **Standardized Encoding**: Both are standardized character encodings designed to facilitate the representation of text.
- **Character Representation**: Both ASCII and UTF-8 represent characters as numeric codes (ASCII for 0â€“127, UTF-8 for all Unicode characters).
- **Control Characters**: Both ASCII and UTF-8 include control characters for text formatting and processing (e.g., line breaks, tabs).
:::



## Indexing and Slicing in Python

In Python, indexing and slicing are used to access elements from sequence data types such as:

-   Strings (str)
-   Lists (list)
-   Tuples (tuple)

These data types are ordered, meaning each element has a position.

**What is Indexing?**: Indexing means accessing a single element from a sequence using its position number, called an index.

> Python uses zero-based indexing, which means the first element starts at index 0.

**Positive Indexing**

-   Index starts from 0
-   Moves from left to right

**Example with a string:**

```{python}
text = "Python"


print(text[0])  # P
print(text[3])  # h

```

**Negative Indexing**

-   Index starts from -1
-   Moves from right to left

```{python}
print(text[-1])  # n
print(text[-3])  # h

```

**Indexing with Lists and Tuples**

-   Indexing works the same way for lists and tuples.

```{python}
numbers = [10, 20, 30, 40]
print(numbers[1])   # 20
print(numbers[-1])  # 40

```

::: callout-tip
## Important Notes on Indexing

-   Accessing an index outside the range causes an error

```{python}
print(text[10])  # IndexError
```

-   Indexing returns only one element
:::

## Slicing in Python

**What is Slicing?**: Slicing is used to extract a portion (sub-sequence) from a sequence.

**Syntax of Slicing**

```{python}
sequence[start : stop : step]
```

| Parameter | Meaning                            |
|-----------|------------------------------------|
| start     | Index to begin slicing (included)  |
| stop      | Index to end slicing (excluded)    |
| step      | Number of steps to jump (optional) |

**Basic Slicing Examples**

```{python}
text = "Python"

print(text[0:4])   # Pyth
print(text[2:5])   # tho

```

> Note: The stop index is not included.

**Slicing Without Start or Stop**

```{python}
print(text[:3])   # Pyt (from beginning)
print(text[2:])   # thon (till end)
print(text[:])    # Python (entire string)

```

**Slicing with Negative Indexes**

```{python}
print(text[-4:-1])  # tho
```

**Slicing with Step Value**

The step defines how many characters to skip.

```{python}
print(text[0:6:2])  # Pto
```

**Reverse a Sequence Using Slicing**

```{python}
print(text[::-1])  # nohtyP
```

This works for strings, lists, and tuples.

### Indexing vs Slicing

| Feature        | Indexing         | Slicing                        |
|----------------|------------------|--------------------------------|
| Access type    | Single element   | Multiple elements              |
| Output         | One value        | Sub-sequence                   |
| Syntax         | `seq[index]`     | `seq[start:stop:step]`         |
| Error possible | Yes (IndexError) | No (safe even if out of range) |

### Indexing and Slicing with Lists

```{python}
data = [10, 20, 30, 40, 50]

print(data[2])      # 30
print(data[1:4])    # [20, 30, 40]
print(data[::-1])   # [50, 40, 30, 20, 10]
```

::: callout-tip
## Key Points for Learners

-   Python indexing starts at 0
-   Negative indexing accesses elements from the end
-   Slicing never includes the stop index
-   Slicing is safe and does not raise errors
-   Works on strings, lists, and tuples
:::

> Indexing gives one element, slicing gives many elements.
