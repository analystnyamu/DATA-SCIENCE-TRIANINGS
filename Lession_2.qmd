---
title: "Day 2: Python Data Types & Variables"
editor: visual
---

## Introduction

In this session, we focus on **how Python stores and works with data**.\
Understanding data types and variables is essential because **all data analysis tasks depend on correctly handling data values**.

::: callout-tip
## Learning Objectives

By the end of this lesson, learners will be able to:

-   Identify common Python data types
-   Assign values to variables
-   Perform basic operations on different data types
:::

------------------------------------------------------------------------

## Variables and Assignment in Python

### What is a Variable?

A **variable** is a name that refers to a value stored in memory.

```{python}
x = 10
y = 5
x + y
```

-   x is the variable name
-   = is the assignment operator
-   10 is the value stored in the variable

Variables allow us to store, reuse, and manipulate data. Variable names should be descriptive and meaningful

### Rules for Naming Variables

-   Must start with a letter or underscore (\_)
-   Cannot start with a number
-   Cannot contain spaces
-   Should be descriptive and meaningful

**Valid variable names**

```{python}
age = 25
total_sales = 5000
```

**Invalid variable names**

```{python}
2age = 25      # starts with a number
total sales = 5000   # contains space
```

## Checking Data Types

Python automatically determines the type of data stored in a variable.

### Common data types:

-   **int** – whole numbers
-   **float** – decimal numbers
-   **str** – text
-   **bool** – True or False values
- **List (list)** – ordered, changeable

**1. Numeric data types**

```{python}
# - **Integer (int)** - Whole numbers (no decimals):
age = 25
participants = 120

# Check type
type(age)
```

**2. String assignment (text data)**

```{python}

course = "Statistics and Data Analysis"
message = "Welcome to Python!"

# Check Type
type(course)

```

**3. Boolean assignment (True / False)**

```{python}
is_registered = True
has_paid = False
passed_exam = True

# Check Type
type(is_registered)
```


## Numeric Data Types

Python supports several numeric types, but the most commonly used are integers and floats.

### Integers (int)

Integers are whole numbers without decimal points.

```{python}
a = 10
b = -3
```

**Examples of integers:**

Examples of integers:

-   Population counts
-   Number of observations
-   Age in completed years


### Floating-Point Numbers (float)

Floats are numbers with decimal points.

```{python}
height = 1.75
temperature = 36.6
```

**Examples of floats:**

- Measurements
- Averages
- Percentages

## String Data Type (str)

A string is a sequence of characters enclosed in:

- Single quotes ' '
- Double quotes " "
- Triple quotes ''' ''' or """ """ (multi-line strings)

**Key Points**

- Strings are immutable (cannot be changed)
- Supports indexing and slicing
- Used to store text

**Examples**

```{python}
name = "Python"
language = 'Programming'

print(name)
print(type(name))

```

## List Data Type (list)

**Definition**: A list in Python is an ordered, mutable collection of elements. Lists can store items of different data types and allow duplicate values.

A list is one of Python’s most versatile data structures. It supports indexing, slicing, modification, iteration, nesting, and dynamic growth—making it essential for data storage and manipulation in Python programs.

**Characteristics of Lists**

| Feature            | Description                                      |
|--------------------|--------------------------------------------------|
| Ordered            | Items maintain insertion order                  |
| Mutable            | Elements can be changed after creation          |
| Indexed            | Each element has a position index               |
| Allows duplicates  | Same value can appear multiple times            |
| Heterogeneous      | Can store different data types                  |


**Creating Lists**

**a) Empty list**

```{python}
a = []
```

**b) Using List literal**

```{python}
numbers = [1,2,3,4]
```

**c) Using constructor**

```{python}
letters = list("python")
letters
```

**Indexing**

Lists use zero-based indexing.

```{python}
nums = [10, 20, 30]
print(nums[0])   # 10
print(nums[-1])  # 30 (last element)
```

**Slicing**

Extract portions of a list.

```{python}
nums = [0,1,2,3,4,5]
nums[1:4]     # [1,2,3]
nums[:3]      # [0,1,2]
nums[::2]     # [0,2,4]
```

**Syntax**: list[start : stop : step]

| Parameter | Meaning                   |
| --------- | ------------------------- |
| start     | Index to begin (included) |
| stop      | Index to end (excluded)   |
| step      | Interval between elements |


**Modifying a List**

Because lists are mutable, you can change elements.

```{python}
nums = [1,2,3]
nums[1] = 100
print(nums)  # [1,100,3]
```

**Common List Methods**

| Method        | Description              | Example         |
| ------------- | ------------------------ | --------------- |
| `append(x)`   | Adds item to end         | `a.append(5)`   |
| `insert(i,x)` | Inserts at index         | `a.insert(1,9)` |
| `remove(x)`   | Removes first occurrence | `a.remove(3)`   |
| `pop(i)`      | Removes by index         | `a.pop(0)`      |
| `clear()`     | Removes all items        | `a.clear()`     |
| `sort()`      | Sorts list               | `a.sort()`      |
| `reverse()`   | Reverses order           | `a.reverse()`   |


**List Operations**

```{python}
## Concatenation
[1,2] + [3,4]   # [1,2,3,4]

## Repetition
[0] * 4   # [0,0,0,0]

## Membership
3 in [1,2,3]   # True

## Looping Through Lists
for item in [10,20,30]:
    print(item)
### With index:
for i, value in enumerate([10,20,30]):
    print(i, value)
```


**Nested Lists**

Lists can contain other lists.

```{python}
matrix = [[1,2],[3,4],[5,6]]
print(matrix[1][0])  # 3
```

**List Comprehension**

A concise way to create lists.

```{python}
squares = [x**2 for x in range(5)]

## With condition:
evens = [x for x in range(10) if x % 2 == 0]

```

**Copying Lists**

Important: Assigning does NOT copy.

```{python}
a = [1,2,3]
b = a        # same reference
```

Proper copy methods:

```{python}
b = a.copy()
b = list(a)
b = a[:]
```

::: callout-tip
## When to Use Lists

Use lists when you need:

- Ordered data
- Modifiable collections
- Iteration
- Dynamic storage
- Storing sequences of results
:::


**Common Errors**

| Error        | Cause                                   |
| ------------ | --------------------------------------- |
| `IndexError` | Accessing out-of-range index            |
| `TypeError`  | Invalid operation (e.g., string + list) |
| `ValueError` | Removing value not present              |


## Tuple Data Type (tuple)

**Definition**: A tuple in Python is an ordered, immutable collection of elements. Once created, its elements cannot be changed, added, or removed.


```{python}
my_tuple = (1, 2, 3, "hello", True)
```

**Characteristics of Tuples**

| Feature           | Description                          |
| ----------------- | ------------------------------------ |
| Ordered           | Maintains insertion order            |
| Immutable         | Cannot be modified after creation    |
| Indexed           | Supports indexing                    |
| Allows duplicates | Same value can appear multiple times |
| Heterogeneous     | Can store mixed data types           |


**Creating Tuples**


```{python}
# a) Empty tuple
t = ()
# b) With elements

nums = (10, 20, 30)

#c) Without parentheses (packing)
t = 1, 2, 3

# d) Single-element tuple (important syntax)
single = (5,)   # comma is required

```

**Other Examples**

```{python}
colors = ("red", "green", "blue")
print(colors)
print(type(colors))


single = (10,)
print(type(single))  # tuple
```

**Indexing**: Tuples support zero-based indexing.

```{python}

t = (10, 20, 30)
print(t[0])   # 10
print(t[-1])  # 30
```

**Slicing**: Works the same as lists.

```{python}
t = (0,1,2,3,4)
t[1:4]     # (1,2,3)
t[:3]      # (0,1,2)
t[::2]     # (0,2,4)
```

**Immutability**: 

You cannot modify tuple elements.

```{python}
t = (1,2,3)
t[1] = 100   # ❌ Error

## Error:
TypeError: 'tuple' object does not support item assignment
```

However, if a tuple contains mutable objects (like lists), those objects can be modified.

```{python}
t = ([1,2], [3,4])
t[0][0] = 99
```

**Tuple Methods**: Tuples have only two built-in methods:

| Method     | Description                  |
| ---------- | ---------------------------- |
| `count(x)` | Counts occurrences of value  |
| `index(x)` | Returns first index of value |

```{python}
t = (1,2,2,3)
t.count(2)   # 2
t.index(3)   # 3
```

**Tuple Operations**

```{python}
## Concatenation
(1,2) + (3,4)   # (1,2,3,4)

## Repetition
(0,) * 3   # (0,0,0)

## Membership
3 in (1,2,3)   # True
```


**Packing and Unpacking**

```{python}
## Packing
person = ("Martin", 25, "Statistician")

## Unpacking
name, age, job = person

## Using star unpacking
a, *b = (1,2,3,4)
# a = 1, b = [2,3,4]

```


**Nested Tuples**

```{python}
nested = ((1,2), (3,4))
nested
print(nested[1][0])   # 3

# nested[1][0] means:

#> “Go to index 1 of nested, then from that result go to index 0.”
```

::: callout-tip
## When to Use Tuples

Use tuples when:

- Data should not change
- You need data integrity
- Storing constants
- Returning multiple values from functions
- Using data as dictionary keys
:::

::: callout-tip
## Advantages of Tuples

- Faster than lists
- Memory efficient
- Safe from accidental modification
- Hashable (can be dictionary keys if elements are immutable)
:::

**Common Errors**

| Error        | Cause                               |
| ------------ | ----------------------------------- |
| `TypeError`  | Trying to modify tuple              |
| `ValueError` | Unpacking wrong number of variables |

```{python}
a, b = (1,2,3)   # ❌ ValueError
```

**Practical Examples**: Returning multiple values

```{python}
def stats(x, y):
    return x+y, x*y

s, p = stats(2,3)
```

**Dictionary key**

```{phton}
location = {(1,2): "Point A"}
```


::: callout-tip
## List vs Tuple

| Feature     | Tuple      | List            |
| ----------- | ---------- | --------------- |
| Mutability  | Immutable  | Mutable         |
| Syntax      | `( )`      | `[ ]`           |
| Methods     | Few        | Many            |
| Performance | Faster     | Slightly slower |
| Use case    | Fixed data | Changing data   |
:::




## Set Data Type (set)

A set is an unordered collection of unique elements.

**Key Points**

- Defined using curly braces { }
- No duplicate values allowed
- Unordered (no indexing)
- Mutable

**Examples**

```{python}
numbers = {1, 2, 3, 4}
print(numbers)
print(type(numbers))


duplicates = {1, 2, 2, 3}
print(duplicates)  # {1, 2, 3}

## Adding Elements

numbers.add(5)
print(numbers)

```

## Dictionary Data Type (dict)

A dictionary stores data in key–value pairs.

**Key Points**

- Defined using {key: value}
- Keys must be unique
- Values can be of any data type
- Mutable

**Examples**

```{python}
student = {
    "name": "Alice",
    "age": 20,
    "course": "Python"
}

print(student)
print(type(student))
```

**Accessing Values**

```{python}
print(student["name"])
```

**Modifying Dictionary**

```{python}
student["age"] = 21
student["grade"] = "A"
print(student)

```

## None Data Type (NoneType)

None represents the absence of a value.

**Key Points**

- Used when a variable has no value
- Often used as a default return value

**Examples**

```{python}
result = None
print(result)
print(type(result))


def test():
    pass

print(test())  # None

```
## Bytes Data Type (bytes)

Used to store binary data.

**Key Points**

- Immutable
- Mainly used in file handling and networking

**Examples**

```{python}
data = b"Hello"
print(data)
print(type(data))


numbers = bytes([65, 66, 67])
print(numbers)  # b'ABC'
```

## Indexing and Slicing in Python

In Python, indexing and slicing are used to access elements from sequence data types such as:

- Strings (str)
- Lists (list)
- Tuples (tuple)

These data types are ordered, meaning each element has a position.

**What is Indexing?**: Indexing means accessing a single element from a sequence using its position number, called an index.

> Python uses zero-based indexing, which means the first element starts at index 0.

**Positive Indexing**

- Index starts from 0
- Moves from left to right

**Example with a string:**

```{python}
text = "Python"


print(text[0])  # P
print(text[3])  # h

```

**Negative Indexing**

- Index starts from -1
- Moves from right to left

```{python}
print(text[-1])  # n
print(text[-3])  # h

```

**Indexing with Lists and Tuples**

- Indexing works the same way for lists and tuples.

```{python}
numbers = [10, 20, 30, 40]
print(numbers[1])   # 20
print(numbers[-1])  # 40

```

::: {.callout-tip}
## Important Notes on Indexing

- Accessing an index outside the range causes an error

```{python}
print(text[10])  # IndexError
```
- Indexing returns only one element
:::

## Slicing in Python

**What is Slicing?**: Slicing is used to extract a portion (sub-sequence) from a sequence.

**Syntax of Slicing**

```{python}
sequence[start : stop : step]
```

| Parameter | Meaning |
|-----------|----------|
| start | Index to begin slicing (included) |
| stop  | Index to end slicing (excluded) |
| step  | Number of steps to jump (optional) |

**Basic Slicing Examples**

```{python}
text = "Python"

print(text[0:4])   # Pyth
print(text[2:5])   # tho

```

> Note: The stop index is not included.

**Slicing Without Start or Stop**

```{python}
print(text[:3])   # Pyt (from beginning)
print(text[2:])   # thon (till end)
print(text[:])    # Python (entire string)

```

**Slicing with Negative Indexes**

```{python}
print(text[-4:-1])  # tho
```

**Slicing with Step Value**

The step defines how many characters to skip.

```{python}
print(text[0:6:2])  # Pto
```

**Reverse a Sequence Using Slicing**

```{python}
print(text[::-1])  # nohtyP
```

This works for strings, lists, and tuples.

### Indexing vs Slicing

| Feature | Indexing | Slicing |
|----------|------------|------------|
| Access type | Single element | Multiple elements |
| Output | One value | Sub-sequence |
| Syntax | `seq[index]` | `seq[start:stop:step]` |
| Error possible | Yes (IndexError) | No (safe even if out of range) |

### Indexing and Slicing with Lists

```{python}
data = [10, 20, 30, 40, 50]

print(data[2])      # 30
print(data[1:4])    # [20, 30, 40]
print(data[::-1])   # [50, 40, 30, 20, 10]
```

::: {.callout-tip}
## Key Points for Learners

- Python indexing starts at 0
- Negative indexing accesses elements from the end
- Slicing never includes the stop index
- Slicing is safe and does not raise errors
- Works on strings, lists, and tuples
:::

> Indexing gives one element, slicing gives many elements.

